// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/pseudomuto/pacman/internal/publisher (interfaces: Packager,Uploader,VCSFetcher)
//
// Generated by this command:
//
//	mockgen -destination=mocks_test.go -package=publisher_test . Packager,Uploader,VCSFetcher
//

// Package publisher_test is a generated GoMock package.
package publisher_test

import (
	context "context"
	io "io"
	reflect "reflect"

	types "github.com/pseudomuto/pacman/internal/types"
	gomock "go.uber.org/mock/gomock"
)

// MockPackager is a mock of Packager interface.
type MockPackager struct {
	ctrl     *gomock.Controller
	recorder *MockPackagerMockRecorder
	isgomock struct{}
}

// MockPackagerMockRecorder is the mock recorder for MockPackager.
type MockPackagerMockRecorder struct {
	mock *MockPackager
}

// NewMockPackager creates a new mock instance.
func NewMockPackager(ctrl *gomock.Controller) *MockPackager {
	mock := &MockPackager{ctrl: ctrl}
	mock.recorder = &MockPackagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPackager) EXPECT() *MockPackagerMockRecorder {
	return m.recorder
}

// Package mocks base method.
func (m *MockPackager) Package(arg0 context.Context, arg1 io.Writer, arg2 types.PackageOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Package", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Package indicates an expected call of Package.
func (mr *MockPackagerMockRecorder) Package(arg0, arg1, arg2 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Package", reflect.TypeOf((*MockPackager)(nil).Package), arg0, arg1, arg2)
}

// Type mocks base method.
func (m *MockPackager) Type() types.ArchiveType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(types.ArchiveType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockPackagerMockRecorder) Type() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockPackager)(nil).Type))
}

// MockUploader is a mock of Uploader interface.
type MockUploader struct {
	ctrl     *gomock.Controller
	recorder *MockUploaderMockRecorder
	isgomock struct{}
}

// MockUploaderMockRecorder is the mock recorder for MockUploader.
type MockUploaderMockRecorder struct {
	mock *MockUploader
}

// NewMockUploader creates a new mock instance.
func NewMockUploader(ctrl *gomock.Controller) *MockUploader {
	mock := &MockUploader{ctrl: ctrl}
	mock.recorder = &MockUploaderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUploader) EXPECT() *MockUploaderMockRecorder {
	return m.recorder
}

// Type mocks base method.
func (m *MockUploader) Type() types.StorageType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(types.StorageType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockUploaderMockRecorder) Type() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockUploader)(nil).Type))
}

// Write mocks base method.
func (m *MockUploader) Write(arg0 context.Context, arg1 io.Reader, arg2 string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Write", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// Write indicates an expected call of Write.
func (mr *MockUploaderMockRecorder) Write(arg0, arg1, arg2 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Write", reflect.TypeOf((*MockUploader)(nil).Write), arg0, arg1, arg2)
}

// MockVCSFetcher is a mock of VCSFetcher interface.
type MockVCSFetcher struct {
	ctrl     *gomock.Controller
	recorder *MockVCSFetcherMockRecorder
	isgomock struct{}
}

// MockVCSFetcherMockRecorder is the mock recorder for MockVCSFetcher.
type MockVCSFetcherMockRecorder struct {
	mock *MockVCSFetcher
}

// NewMockVCSFetcher creates a new mock instance.
func NewMockVCSFetcher(ctrl *gomock.Controller) *MockVCSFetcher {
	mock := &MockVCSFetcher{ctrl: ctrl}
	mock.recorder = &MockVCSFetcherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockVCSFetcher) EXPECT() *MockVCSFetcherMockRecorder {
	return m.recorder
}

// FetchArchive mocks base method.
func (m *MockVCSFetcher) FetchArchive(arg0 io.Writer, arg1 string, arg2 types.VCSOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchArchive", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// FetchArchive indicates an expected call of FetchArchive.
func (mr *MockVCSFetcherMockRecorder) FetchArchive(arg0, arg1, arg2 any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchArchive", reflect.TypeOf((*MockVCSFetcher)(nil).FetchArchive), arg0, arg1, arg2)
}

// Type mocks base method.
func (m *MockVCSFetcher) Type() types.VCSType {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Type")
	ret0, _ := ret[0].(types.VCSType)
	return ret0
}

// Type indicates an expected call of Type.
func (mr *MockVCSFetcherMockRecorder) Type() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Type", reflect.TypeOf((*MockVCSFetcher)(nil).Type))
}
